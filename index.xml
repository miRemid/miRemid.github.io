<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>狸猫窝</title><link>https://blog.thinkmoe.icu/</link><description>Recent content on 狸猫窝</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Mon, 28 Mar 2022 16:40:37 +0800</lastBuildDate><atom:link href="https://blog.thinkmoe.icu/index.xml" rel="self" type="application/rss+xml"/><item><title>Ubuntu20.04 Install Opencv3.1.0 With Python3</title><link>https://blog.thinkmoe.icu/posts/ubuntu20.04-install-opencv3.1.0-with-python3/</link><pubDate>Mon, 28 Mar 2022 16:40:37 +0800</pubDate><guid>https://blog.thinkmoe.icu/posts/ubuntu20.04-install-opencv3.1.0-with-python3/</guid><description>安装依赖 Ubuntu20.04需要安装以下依赖
sudo apt install -y --no-install-recommends \ build-essential \ git \ wget \ unzip \ yasm \ pkg-config \ libswscale-dev \ libtbb2 \ libtbb-dev \ libjpeg-dev \ libpng-dev \ libtiff-dev \ libopenjp2-7-dev \ libavformat-dev \ libpq-dev \ libgtk2.0-dev libgtk-3-dev \ libgphoto2-dev \ libtiff5-dev libjpeg8-dev libpng-dev cmake make \ libavformat-dev libavcodec-dev libswscale-dev libdc1394-22-dev libavresample-dev \ libxine2-dev libv4l-dev \ libatlas-base-dev \ libfaac-dev libmp3lame-dev libtheora-dev \ libvorbis-dev libxvidcore-dev \ libeigen3-dev \ libgstreamer1.</description></item><item><title>ROS2虚拟环境配置指南</title><link>https://blog.thinkmoe.icu/posts/ros2%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E6%8C%87%E5%8D%97/</link><pubDate>Tue, 22 Feb 2022 14:35:57 +0800</pubDate><guid>https://blog.thinkmoe.icu/posts/ros2%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E6%8C%87%E5%8D%97/</guid><description>在使用CARLA的ROS2包的过程中，需要导入torch对图像进行处理，按照正常情况下，激活conda环境之后应该就能够直接使用虚拟环境中安装的第三方包，但是在ROS2启动的过程中却提示torch not found的错误
开始怀疑是conda环境导致的，于是更换为官方的venv，但是在安装完依赖后编译启动显示还是同样的错误。
在Github搜索后发现，原来通过colcon编译的ROS2节点在启动的时候默认使用系统环境的Python环境运行，并不会加载编译时使用的虚拟环境，因此在虚拟环境中安装的第三方依赖也不会正常使用了。根据rotu的说法，由于ROS2节点的运行文件是由colcon编译生成，而在colcon编译过程中解释器的选择是写死为系统环境的Python的，那是不是ROS2就用不了虚拟环境运行呢？
当然不是，根据上个链接的说法，可以通过修改ROS2的配置文件来间接的让系统使用虚拟环境中的Python解释器，按照theunkn0wn1的描述，总共分为4步
修改setup.cfg文件，添加如下配置 # src/{node}/setup.cfg [build_scripts] executable = /usr/bin/env python3 创建虚拟环境 在创建虚拟环境时，需要将系统环境中的ROS2包链接到虚拟环境中 python3 -m venv venv --system-site-packages --symlinks 这时在目录中会生成venv文件
激活ros2环境配置和虚拟环境配置 source /opt/ros/foxy/setup.zsh source ./venv/bin/activate colcon build并运行 colcon build ros2 run package_name node_name 这时就可以使用到虚拟环境中的第三方包了</description></item><item><title>使用Pytorch预训练网络获取图片特征</title><link>https://blog.thinkmoe.icu/posts/%E4%BD%BF%E7%94%A8pytorch%E9%A2%84%E8%AE%AD%E7%BB%83%E7%BD%91%E7%BB%9C%E8%8E%B7%E5%8F%96%E5%9B%BE%E7%89%87%E7%89%B9%E5%BE%81/</link><pubDate>Fri, 17 Dec 2021 17:52:42 +0800</pubDate><guid>https://blog.thinkmoe.icu/posts/%E4%BD%BF%E7%94%A8pytorch%E9%A2%84%E8%AE%AD%E7%BB%83%E7%BD%91%E7%BB%9C%E8%8E%B7%E5%8F%96%E5%9B%BE%E7%89%87%E7%89%B9%E5%BE%81/</guid><description>由于Carla训练过程中需要使用到图像数据，而通常深度强化学习(DRL)算法中，输入的数据都为一个 向量(Vector)，如果需要使用图像这种二维数据，通常的做法是使用一个CNN网络，提取图像的特征， 将二维数据转化为一维向量数据，这样就能够直接使用现有的DRL算法
例如在stable_baseline3中，支持MLP、CNN和 多种不同类型观测对象混合输入。对于图像数据，都使用了一个基于CNN深度卷积网络来提取特征。
在pytorch中已经有了很多优秀的CNN特征提取网络，在这里我将会使用到MobileNetV3这个网络用 于提取Carla的摄像头图片特征。
读取模型 首先需要安装torchvision这个包，里面包含了现有非常流行的图像处理网络
pip install torchvision 然后打开一个终端，导入torchvision.models模型包
from torchvision import models 导入MobileNetV3并初始化 Pytorch为每个网络都提供了一个预训练好的结构，可以自动下载导入
mobilenet = models.mobilenet.mobilenet_v3_small(pretrained=True) mobilenet.eval() 下面就是MobileNetV3的网络结构，从最终输出层可以得知，MobileNetV3会提取1000个特征值
MobileNetV3( (features): Sequential( (0): ConvNormActivation( (0): Conv2d(3, 16, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1), bias=False) (1): BatchNorm2d(16, eps=0.001, momentum=0.01, affine=True, track_running_stats=True) (2): Hardswish() ) (1): InvertedResidual( (block): Sequential( (0): ConvNormActivation( (0): Conv2d(16, 16, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1), groups=16, bias=False) (1): BatchNorm2d(16, eps=0.001, momentum=0.01, affine=True, track_running_stats=True) (2): ReLU(inplace=True) ) (1): SqueezeExcitation( (avgpool): AdaptiveAvgPool2d(output_size=1) (fc1): Conv2d(16, 8, kernel_size=(1, 1), stride=(1, 1)) (fc2): Conv2d(8, 16, kernel_size=(1, 1), stride=(1, 1)) (activation): ReLU() (scale_activation): Hardsigmoid() ) (2): ConvNormActivation( (0): Conv2d(16, 16, kernel_size=(1, 1), stride=(1, 1), bias=False) (1): BatchNorm2d(16, eps=0.</description></item><item><title>Docker多级构建指南</title><link>https://blog.thinkmoe.icu/posts/docker%E5%A4%9A%E7%BA%A7%E6%9E%84%E5%BB%BA%E6%8C%87%E5%8D%97/</link><pubDate>Wed, 25 Aug 2021 09:01:12 +0800</pubDate><guid>https://blog.thinkmoe.icu/posts/docker%E5%A4%9A%E7%BA%A7%E6%9E%84%E5%BB%BA%E6%8C%87%E5%8D%97/</guid><description>多级构建让你的容器更小巧~
在构建Docker镜像的时候经常发现构建出来的容器大小非常的大，而我本地编译出来的二进制文件也不过26MB左右而Docker容器居然有120MB！ 问题出现在哪里了呢？我们一步一步从最起始的地方开始看起
构建方式 Docker容器的构建方法我个人常用以下几种
本地打包二进制后直接放入Docker中运行 容器内打包直接运行 第一种的方式就是在本地编译好要执行的文件之后放入容器之中运行，这种方式无疑是最简单的方法也是最容易理解的方法。 但这种方法仔细一想就会发现有很多问题，假设我们需要在Windows机器编译Linux版本的容器内运行要怎么办呢？ 除此之外，假设我们换了一台机器也需要编译一份Docker镜像时，本地没有对应的编译工具要如何解决呢？ 为了应对上述问题，也就有了第二种方法。
第二种的方式就是将代码放在容器内部编译，这样既解决了编译环境问题也解决了编译平台的问题。 但第二种方法带来的问题就是我今天要说的，那就是打包后的镜像体积过大，完全不如第一种打包出来的镜像。 这是因为，第一种只是将二进制文件放入容器内直接运行，而第二种还添加了项目的源代码文件，除此之外，还有一堆用于 编译二进制文件的工具在镜像之中，因此打包出来的镜像体积会非常巨大。 那有没有一种方法既能随意构建又不产生大体积的镜像呢？那就要谈谈Docker的多级构建了。
多级构建 Docker的多级构建也就是常说的multi-stage build，你可以通过指定多个stage分别完成不同的任务最后合在一起完成最终的构建。
例如有一个Go的项目，我们可以在stage1阶段进行编译操作，而在stage2阶段进行运行操作，这样就相当于构建1和2相结合，完成最后的构建。
多级构建其实非常简单，其精髓就在于一个命令那就是COPY，这个命令不仅仅可以将本地文件拷贝至Docker的build进程上下文中，还可以在多个stage中 进行文件的复制，而ADD命令则只能用于前者，因此我通常在第一级构建时使用ADD命令将所有的源代码复制到Docker上下文中后，使用COPY应对其他层级的构建。COPY的参数非常简单
COPY --from=stage source dest 其中from就是用于表明从哪个stage中复制文件，不添加该参数则默认从宿主机中复制文件。stage可以用数字表示从第几级复制(从0开始)，也可以用字符串来指定层级复制但需要对层级进行命名
# builder stage FROM x as builder # final stage FROM x as final COPY --from=builder /abc /abc COPY --from=0 /abc/abc 实战 以我的Yuki为例，该项目由React和Go组成，其中Go将会提供服务器提供前端接口。
首先分析阶层，我们需要编译两个项目，其中是React另一个是Go，并且Go的编译需要依赖于React。因此很容易得出，以下顺序
编译React 编译Go 运行 为了让编译出来的容器尽可能的小，我们在选取构建容器时也尽量选择小的容器来进行编译例如我最喜欢的alpine。因此在Docker Hub中寻找关于nodejs和golang的alpine版本，由于原版golang的alpine版本不附带gcc因此我选择了第三方的容器tetafro/golang-gcc。而提供运行环境的容器我也选择了alpine:3.14
NodeJS: node:14.17.5-alpine(117MB) Golang: tetafro/golang-gcc:1.16-alpine(425MB) Runtime: alpine:3.</description></item><item><title>Ubuntu Server 20.04 设置IP和网关地址</title><link>https://blog.thinkmoe.icu/posts/ubuntu-server-20.04-%E8%AE%BE%E7%BD%AEip%E5%9C%B0%E5%9D%80%E5%92%8C%E7%BD%91%E5%85%B3%E5%9C%B0%E5%9D%80/</link><pubDate>Thu, 19 Aug 2021 15:36:40 +0800</pubDate><guid>https://blog.thinkmoe.icu/posts/ubuntu-server-20.04-%E8%AE%BE%E7%BD%AEip%E5%9C%B0%E5%9D%80%E5%92%8C%E7%BD%91%E5%85%B3%E5%9C%B0%E5%9D%80/</guid><description>Ubuntu从20.04版本开始使用netplan对网络进行管理，百度上使用的/etc/network/interfaces文件已不再适用，需要修改netplan配置文件进行更新
修改配置文件 netplan的配置文件存放在/etc/netplan中，其中有诸如00-installer-config.yaml的配置文件，打开可以发现
# This is the network config written by &amp;#39;subiquity&amp;#39;network:ethernets:# 网卡名称，我这是虚拟机ens33ens33:# 是否开启dhcp服务，设置为true后后续的ip和网关可以不用设置dhcp4:no# IP地址，一般设置一个就行# 后面的24是子网掩码数目，代表255.255.255.0(11111111.11111111.11111111.00000000)addresses:[192.168.1.106/24]optional:true# 网关地址gateway4:192.168.1.253# dns地址nameservers:addresses:[233.5.5.5,192.168.1.253]version:2当然，这只是最为基础的网络配置，对于多张网卡还可以进行其他的配置，详情可以参考Netplan官方文档
在修改完文件之后，终端输入以下命令应用配置，Ping外网测试连通性
sudo netplay apply ping 8.8.8.8</description></item><item><title>Websocket关闭错误代码含义</title><link>https://blog.thinkmoe.icu/posts/websocket%E5%85%B3%E9%97%AD%E9%94%99%E8%AF%AF%E4%BB%A3%E7%A0%81%E5%90%AB%E4%B9%89/</link><pubDate>Sat, 07 Aug 2021 15:00:19 +0800</pubDate><guid>https://blog.thinkmoe.icu/posts/websocket%E5%85%B3%E9%97%AD%E9%94%99%E8%AF%AF%E4%BB%A3%E7%A0%81%E5%90%AB%E4%B9%89/</guid><description>前情 在处理B站直播的Websocket源时，经常发生连接关闭的错误，最常见的就是close 1006 (abnormal closure): unexpected EOF错误，你说http的状态码还知道，这websocet的状态码还真不知道，于是去查了查记录一下
RFC 6455 根据RFC 6455定义的内容，Websocket在处理关闭时设置了一系列的代码提示。当对一个已经建立的连接进行关闭时，在终端处可能提供一个关闭的解释说明，客户端可以根据这个代码来推测终端关闭连接的原因从而更新客户端连接的代码。当然，终端在关闭时也可以忽视代码直接进行关闭
1000 Normal Closure 1000表明这是一个正常的关闭，表明要传输的数据已经全部完成可以退出
1001 Going Away 1001说明终端可能已经找不到该连接，例如服务可能宕机或浏览器重定向至其他页面
1002 Protocal error 1002说明连接被终端由于消息协议错误而进行强制性退出
1003 Unsupported Data 1003说明终端接受到一个无法处理的数据而进行强制性退出(例如，服务器可能只能够处理文本数据但接受到了二进制数据)
1004 &amp;mdash;Reserved&amp;mdash; 1004字段保留，未来可能用得到
1005 No Status Rcvd 1005是一个保留数据，绝对不允许终端将其设置为关闭时的状态码。It is designated for use in applications expecting a status code to indicate the no stats code was actually present.
1006 Abnormal Closure 1006是一个保留数据，绝对不允许终端将其设置为关闭时的状态码。它是用来指定需要状态码标志连接异常关闭的程序，例如没有发送或接受控制数据</description></item><item><title>Leetcode 每日一题</title><link>https://blog.thinkmoe.icu/posts/leetcode-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</link><pubDate>Fri, 23 Jul 2021 11:50:27 +0800</pubDate><guid>https://blog.thinkmoe.icu/posts/leetcode-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</guid><description>2021/7/23 1893 Check if All the Integers in a Range Are Covered (EASY) You are given a 2D integer array ranges and two integers left and right. Each ranges[i] = [starti, endi] represents an inclusive interval between starti and endi.
Return true if each integer in the inclusive range [left, right] is covered by at least one interval in ranges. Return false otherwise.
An integer x is covered by an interval ranges[i] = [starti, endi] if starti &amp;lt;= x &amp;lt;= endi.</description></item><item><title>Windows11是如何运行安卓应用的</title><link>https://blog.thinkmoe.icu/posts/windows11%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%90%E8%A1%8C%E5%AE%89%E5%8D%93%E5%BA%94%E7%94%A8%E7%9A%84/</link><pubDate>Thu, 01 Jul 2021 15:25:32 +0800</pubDate><guid>https://blog.thinkmoe.icu/posts/windows11%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%90%E8%A1%8C%E5%AE%89%E5%8D%93%E5%BA%94%E7%94%A8%E7%9A%84/</guid><description>本文翻译自arstechnica
微软在发布Windows11时公布了一个令人惊喜的东西，Windows11将支持Win应用和安卓应用同时运行。但是，并没有在关键的地方留下太多的信息。这些应用是否是通过模拟器运行的呢？现存与Windows的Linux子系统将会被放弃吗？我们将在这篇文章得到答案，同时感谢以下开发者探讨这些细节。
微软官方将这个功能称之为“为安卓而生的Windows子系统”，这也向你说明了许多关于它如何工作的信息。Windows目前拥有一个Linux子系统（WSL），它使用Windows下的Hyper-V虚拟机的功能让Windows能在一个独立的环境下使用一个真正意义上的Linux系统来运行Linux应用。（Hyper-V让次系统能够访问宿主机的硬件而不是通过在原生资源上套用一个顶层的管理操作系统从而只能使用少数宿主机资源）。一个现实中的安卓手机运行的是Linux内核，而微软正在为Windows的安卓子系统建立一个基于WSL的安卓框架。这看上去非常类似于在Hyper-V虚拟机中运行x86架构的安卓系统。
在Windows下运行安卓应用就如同在原生机器上运行Windwos原生应用一样，顶层有窗口栏，任务图标，并且可以“钉”在开始菜单中。在发布会中，微软说：“在屏幕背后，我们还创建栏一个代理应用用于处理安卓运行和Windows引用之间的交互”。这大概可以推测，系统将会提供类似于启动快捷键、图标和卸载入口，并且其窗口化的模式让应用看起来像原生应用一样。
微软正在尝试通过类似于小型模拟器或不基于模拟器的形式来实现这个功能，而这一切取决于你的电脑和应用兼容性。Windows系统和安卓系统都能在x86架构和arm架构下运行，但安卓更倾向于Arm而Windows倾向于x86.如果你正在使用Arm架构的Windows并想在Windows上运行安卓应用，一切都可能非常顺利。但如果你使用的是x86的Windows，微软在像方法让你能够使用到x86类型的安卓应用。Arm的应用只需要支持一件东西，那就是&amp;quot;Intel Bridge Technology&amp;quot;，该技术的目的就是能让arm架构的代码转化为x86架构能够运行的代码。微软正在寻求在AMD处理器上能够实现相同功能的方法。
微软的方法类似于其他一些操作系统如何启动和运行Android应用程序。ChromeOS的安卓支持可能是最适合的例子了。ChromeOS运行在Linux内核之中，并且它存储了一个容器化的安卓框架来运行应用。如果你有一个x86架构的ChromeBook，ChromeOS会使用安卓的Arm-to-x86编译版本。如果你使用的是Linux桌面系统，有一个名为Anbox的应用将会帮你完成上述一样的事情，在Linux系统之上加载一个安卓框架。你甚至能在WSL中运行Anbox。
许多人上一次体验x86的安卓还是在2012年时，intel推行的Atom-powered的x86架构手机。X86已经走了一段很久的历史了，直到2016年安卓ChromeOS开始，才让其缓了一口气。甚至在2016年启动之前，谷歌还在减少推送x86架构的app支持，并且谷歌开发者工具也将arm和x86分离。回到2016年，谷歌希望25%的商城应用不再需要去支持x86架构而是转向arm应用。现如今，众多的x86用户需要感谢chromeos来让其能够运行安卓应用。
亚马逊，区别于谷歌商店的市场系统 微软并不会在Windows上使用谷歌市场，同时，微软也并不会尝试自己来建立经济市场而是通过合作伙伴亚马逊，用在FireOs设备上的亚马逊市场来进行安卓应用下载。亚马逊已经推出来一个预览版本，但并没有提供一个准确的稳定性版本开放日期。
我们并没有看到一个安卓应用是如何在Windows上启动和关闭的，所以并不清楚它们是如何在Windows上工作地。微软放出了很多截图，展示来微软商店在推送亚马逊App商店的安卓应用。从这些放出的消息来看，亚马逊App已经内置于Windows之中，但并没有看到微软商店能够直接安装安装应用。关键点就是安装按钮，对于Windows应用，安装按钮显示的是&amp;quot;Get&amp;quot;来表明安装一个应用。对于安卓应用来说，则显示的是&amp;quot;从亚马逊商店中获得&amp;quot;，并且使用来一个小盒子和箭头图标来表示，这代表你将会通过另一个额外的应用来获取该安卓应用。
华尔街提供了一个额外的细节来展示其是如何工作的。这听起来就像是亚马逊在给Windows提供了一个亚马逊商城客户端。你只需要登录你的亚马逊帐号，就可以下载应用了。微软上面只提供了搜索的功能。确切来说，这表明你将会在Windows上同时运行两个应用商店，使用两份空间来检查更新。这看上去并不稳定。
微软工程师Miguel de Icaza确认，Windows11将会通过sideloading技术来支持那些我们不需要的亚马逊功能。您应该立即为F-Droid等开源商店提供选项，以及在APKMIRROR应用上加载的能力。 在有人获得整个Google Play商店工作之前，这可能只是时间问题。
由于多年的默认和推动加上额外的架构支持，X86应用程序普遍存在于Google商店中。但是亚马逊App商店X86普遍存在吗？你可以在任何安卓设备上侧载亚马逊应用商店，但专门使用Amazon的Echo File设备的都是ARM。许多应用程序都已经开发完成并在所有架构上运行，所以&amp;hellip;&amp;hellip;也许。
如果微软撤回了Surface Duo并与Google一起使用的Windows 11中的实际Play商店会很好。在Play商店外使用Android的问题是您丢失对Google Play服务API的访问和推送通知。亚马逊一直在为Fire操作系统构建自己的替代API和云服务，如果你不能拥有Google Play，这是下一个最好的事情。
这就是我们现在在Windows 11 Android兼容性上所拥有的一切。但放心，我们会在一些实际代码出来时更深入的探究。</description></item><item><title>React钩子对比Redux，谁能在状态管理更胜一筹?</title><link>https://blog.thinkmoe.icu/posts/react%E9%92%A9%E5%AD%90%E5%AF%B9%E6%AF%94redux%E8%B0%81%E8%83%BD%E5%9C%A8%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E6%9B%B4%E8%83%9C%E4%B8%80%E7%AD%B9/</link><pubDate>Mon, 21 Jun 2021 14:47:25 +0800</pubDate><guid>https://blog.thinkmoe.icu/posts/react%E9%92%A9%E5%AD%90%E5%AF%B9%E6%AF%94redux%E8%B0%81%E8%83%BD%E5%9C%A8%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E6%9B%B4%E8%83%9C%E4%B8%80%E7%AD%B9/</guid><description>本文翻译自Nicola Grujicic
React状态管理：Hook和Redux，两者有何不同？ 世界上很多包括我在内的开发者都有一个疑惑，在听到人们使用Hook代替Redux时，为什么要将一个多级别工作非常完美的组件用一个新的还未完成的东西替代
许多人在疑惑useContext和useReducer是否能代替Redux
今天，我将会尝试去回答这个问题。我将会解释React的钩子(useContext,useReducer)和Redux的不同之处以及使用场景
两者最大的查表在于如何管理应用的全局状态
Redux是当开发者需要创建一个大型的复杂的应用时管理全局状态的最佳实践，它提供了一个相当于存储中心的组件用于保管需要在整个应用中使用的状态信息。并通过一系列规则保证状态只有在指向性的数据流中被更新
Reack钩子则是用另一种全新的方式在组件的生命周期中来管理状态信息并且并不依赖于组件。它在16.8版本中首次提出，旨在通过组件分享逻辑来降低组件之间的复杂性
两者最大的不同就是，Redux创建了一个包裹在整个应用之外的全局状态容器，这个容器被称之为store并且通过useReducer创建一个独立的组件用于和应用组件进行合作
另外一点是，React钩子使用useContext和useReducer联合去和组件状态管理进行合作，这已经是另一个层面的合作关系。它让通过useReducer创建的状态容器和它的dispatch函数能够传递给从最顶端组件以下的任意一个组件之中。你可以在最顶端组件中定义它们使其变为全局状态
如果我们将我们创建的所有state放置在最外层的组件，这体验感觉就和使用Redux没有什么区别
所以是Context(上下文)可能代替Redux(但也不一定)
对于Redux，使用钩子的好处有
并不需要持续关注Redux第三方依赖的更新，避免更新所导致的Bug和问题，可以让你的应用大小变得更小也因此会有更快的速度来处理状态变化。可以让代码更为清晰便于理解，并且通过钩子来创建组件可以用更少的代码获取更快的响应速度
尽管看上去使用useReducer和Redux没什么区别，但它并不是Redux。useReducer函数和其reducer紧密联系在一起，使得能够使用它的dispatch函数。但我们仅仅向reducer传递dispatch的action对象而已
你可以认为Redux是一个全局状态总线，它将承载任意一个事件(action)并且基于action提供的数据和状态进行处理
总结 Redux和其他React状态管理解决方案之所以被提出是因为在React组件中管理一个全局状态是一个非常愚蠢的想法。如果这么做会导致一系列问题，如多源数据和使用虚拟模型代替原始模型展示等等
如果钩子能够让状态管理更清晰，我认为在小型应用中可以尝试不使用Redux。但对于大型的复杂的应用程序，全局状态管理仍然不能被忽略</description></item><item><title>利用fusuma为Linux添加触控板手势</title><link>https://blog.thinkmoe.icu/posts/%E5%88%A9%E7%94%A8fusuma%E4%B8%BAlinux%E6%B7%BB%E5%8A%A0%E8%A7%A6%E6%8E%A7%E6%9D%BF%E6%89%8B%E5%8A%BF/</link><pubDate>Sat, 19 Jun 2021 21:07:52 +0800</pubDate><guid>https://blog.thinkmoe.icu/posts/%E5%88%A9%E7%94%A8fusuma%E4%B8%BAlinux%E6%B7%BB%E5%8A%A0%E8%A7%A6%E6%8E%A7%E6%9D%BF%E6%89%8B%E5%8A%BF/</guid><description>之前一直在新笔记本上用虚拟机开Linux编写毕设，现在毕业答辩已经完成，所以就直接将Win10更换到Linux系统。但是众所周知，Linux并没有自带触控板手势驱动，但我早已习惯于win上的一些手势，所以我开始寻找一个合适的触控板手势驱动。
在最初，我发现了一个名为libinput-gesture的库，其Github上有3k赞，于是我立马就尝试了这个库。安装过程一切畅通，但最后运行的阶段却出了问题。在启动该库时提示我启动失败，但并没有给其他错误信息。我检查了xinput和libinput对触控板的驱动，并没有任何问题。谷歌了一下发现这玩意对arch用户非常良好，但对我这使用的ubuntu来说会出现这种情况。于是我把目光转向另一个库，fusuma。
fusuma这个包非常完美的解决了Ubuntu触控板手势的问题，并且安装过程极其简单，配置也十分简洁明了。
安装 配置用户权限 首先需要配置一下用户状态组，将用户添加到input组中
sudo gpasswd -a $USER input newgrp input // 立刻刷新 对于Debian系用户(Ubuntu,Debian,Mint,Pop!OS) 安装libinput sudo apt install libinput-tools 安装Ruby 由于fusuma需要在ruby上运行，因此需要安装ruby。
sudo apt install ruby 安装Fusuma sudo gem install fusuma 安装xdotool(可选，但是对后续非常有用建议安装) sudo apt install xdotool 对于Arch用户 sudo pacman -S libinput ruby xdotool sudo gem install fusuma 启动 fusuma 配置 Fusuma的配置非常简单，首先需要在用户目录下创建配置文件~/.config/fusuma/config.yml
mkdir -p $HOME/.config/fusuma touch $HOME/.config/fusuma/config.yml 这里简单贴出我使用的配置，可以在配置中发现，其实手势是通过xdotool工具间接调用系统的快捷键来实现手势控制的
swipe:3:left:command:&amp;#34;xdotool key alt+Right&amp;#34;# History forwardright:command:&amp;#34;xdotool key alt+Left&amp;#34;# History back#up:#command: &amp;#34;xdotool key super&amp;#34; # Activity#down:#command: &amp;#34;xdotool key super&amp;#34; # Activity4:left:command:&amp;#34;xdotool key alt+u&amp;#34;# Switch to next workspaceright:command:&amp;#34;xdotool key alt+d&amp;#34;# Switch to previous workspaceup:command:&amp;#34;xdotool key alt+u&amp;#34;# Switch to next workspacedown:command:&amp;#34;xdotool key alt+d&amp;#34;# Switch to previous workspacepinch:in:command:&amp;#34;xdotool keydown ctrl click 4 keyup ctrl&amp;#34;# Zoom inout:command:&amp;#34;xdotool keydown ctrl click 5 keyup ctrl&amp;#34;# Zoom out在添加完配置文件后，重新启动fusuma即可使用手势动作了</description></item></channel></rss>