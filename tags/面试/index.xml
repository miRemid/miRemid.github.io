<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>面试 on 狸猫窝</title><link>https://blog.thinkmoe.icu/tags/%E9%9D%A2%E8%AF%95/</link><description>Recent content in 面试 on 狸猫窝</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Thu, 09 Mar 2023 14:42:35 +0800</lastBuildDate><atom:link href="https://blog.thinkmoe.icu/tags/%E9%9D%A2%E8%AF%95/index.xml" rel="self" type="application/rss+xml"/><item><title>TopK面试题1</title><link>https://blog.thinkmoe.icu/posts/topk%E9%9D%A2%E8%AF%95%E9%A2%981/</link><pubDate>Thu, 09 Mar 2023 14:42:35 +0800</pubDate><guid>https://blog.thinkmoe.icu/posts/topk%E9%9D%A2%E8%AF%95%E9%A2%981/</guid><description>TopK来源
使用递归及非递归两种方式实现快速排序 快排思想，选取一个哨兵节点，从左边寻找到第一个比哨兵大的节点，从右边寻找到第一个比哨兵小的节点，交换两者位置。 如果寻找过程中没有找到对应的元素，则说明排序已经完成
首先是递归的方式
func quick_sort(nums []int){ _quick_sort(nums, 0, len(nums)-1) } func _quick_sort(nums []int, left, right int) { if left &amp;gt;= right { return } k := nums[right] l, r := left, right - 1 for l &amp;lt; r { for l &amp;lt; r &amp;amp;&amp;amp; nums[i] &amp;lt; k { l++ } for r &amp;gt; l &amp;amp;&amp;amp; nums[r] &amp;gt; k { r-- } nums[l], nums[r] = nums[r], nums[l] } nums[right], nums[l] = nums[l], nums[right] _quick_sort(nums, left, l-1) _quick_sort(nums, l+1, right) } 非递归版本，其实就是用栈模拟递归</description></item></channel></rss>