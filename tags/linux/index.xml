<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Linux on 狸猫窝</title><link>https://blog.thinkmoe.icu/tags/linux/</link><description>Recent content in Linux on 狸猫窝</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Sun, 05 Mar 2023 22:01:11 +0800</lastBuildDate><atom:link href="https://blog.thinkmoe.icu/tags/linux/index.xml" rel="self" type="application/rss+xml"/><item><title>Jetson TX2 NX 配置笔记</title><link>https://blog.thinkmoe.icu/posts/jetson-tx2-nx-%E9%85%8D%E7%BD%AE%E7%AC%94%E8%AE%B0/</link><pubDate>Sun, 05 Mar 2023 22:01:11 +0800</pubDate><guid>https://blog.thinkmoe.icu/posts/jetson-tx2-nx-%E9%85%8D%E7%BD%AE%E7%AC%94%E8%AE%B0/</guid><description>Jetson真的好贵啊&amp;gt; &amp;lt;
tx2nx开发板
由于科研的需要，需要在边缘设备上对深度学习模型进行量化测试。实验室内刚好有闲置的Nvidia Jetson TX2开发板，所以就直接拿来测试了
原本以为在开发板上的配置会比较简单，无非就是从x86平台转换到arm上面，但实际上坑非常多例如前面提到的arm架构，其实在Jetson上面压根不是传统的arm架构，而是从armv8独立分支出来的aarch架构
虽然坑非常多，但总体上配置流程也非常简洁，基本配置过程也和x86平台上面大致相同，只是在安装的时候需要注意。本文大纲如下
烧录安装系统 安装conda虚拟环境 安装Pytorch和torchvision 安装torch2trt 安装系统 首先需要烧录镜像到开发板中，由于我这块板子在购买的时候代理商就已经烧录好了系统到固件中，因此直接开机即可
如果是裸板安装，则可以参考知乎的教程进行烧录安装
连接电源启动开发板，在安装界面中可以选择启用CPU核心的选项，默认是4核，对应的SWAP大小为2GB，可以按照自己的需求进行更改。当然，如果已经安装完了系统也可以在系统中进行修改。
tx2自带的存储大小非常小只有16GB，按需求进行扩容，我这里是外接了一块128G的SSD硬盘
安装conda虚拟环境 按照本人的习惯，需要一个虚拟环境用于区分不同项目的环境，在tx2也不例外。这里就出现了第一个坑，那就是官方的conda并不能在tx2上完美运行！ 就算你下载的是aarch架构的脚本，你在安装过程中也可能报错，又或者即使安装成功你在创建虚拟环境选择低版本的Python时也会出现错误
为了解决这个问题，我们需要使用一个修改版的conda，那就是Mambaforge。从官方的Release中下载所需要的脚本文件(注意得是aarch架构的文件！)，安装方式则和普通版本的conda如出一辙，需要注意的是安装的位置需要选择一个容量更大的硬盘上面
wget https://github.com/conda-forge/miniforge/releases/download/22.11.1-4/Mambaforge-22.11.1-4-Linux-aarch64.sh sh Mambaforge-22.11.1-4-Linux-aarch64.sh 随后创建你的第一个环境吧
conda create -n hello python=3.6 conda activate hello 安装Pytorch和torchvision 在安装Pytorch前，你需要安装Jetson的CUDA环境，默认情况下是没有的，当然在Nvidia自家产品上安装CUDA环境非常简单，不像Linux那样惹人厌。安装只需要一条命令即可
sudo apt install nvidia-jetpack 这时，查看/usr/local中应该就会出现对应的CUDA环境了，Jetpack会帮助你安装CUDA工具包、TensorRT和其他工具，你可以通过jetson_release来查看当前安装的CUDA版本
(base) tx2-1@tx2-1-desktop:/usr/local$ jetson_release Software part of jetson-stats 4.1.5 - (c) 2023, Raffaello Bonghi Model: lanai-3636 - Jetpack 4.6.1 [L4T 32.7.1] NV Power Mode: MAXP_CORE_ARM - Type: 3 jtop: - Version: 4.</description></item><item><title>WSL2更改桥接网络</title><link>https://blog.thinkmoe.icu/posts/wsl2%E6%9B%B4%E6%94%B9%E6%A1%A5%E6%8E%A5%E7%BD%91%E7%BB%9C/</link><pubDate>Thu, 05 May 2022 13:34:24 +0800</pubDate><guid>https://blog.thinkmoe.icu/posts/wsl2%E6%9B%B4%E6%94%B9%E6%A1%A5%E6%8E%A5%E7%BD%91%E7%BB%9C/</guid><description>WSL2默认情况下网络是处于NAT模式之下，在正常情况下联网是没有问题的，但是遇到一些特殊情况下时NAT网络就非常的鸡肋。 例如，NAT的WSL2并不能直接使用宿主机的代理服务器，需要手动获取本机IP和宿主机在WSL2中的IP地址才能进行局域网连接。 在例如本人需要在WSL2中远程连接实验室车辆上的ROS2节点，由于NAT的存在导致小车上ROS2节点发布的Topic并不能在WSL2中接收到，因此我需要将WSL2默认的NAT网络 更改为桥接网络，这样在不影响宿主机上网的同时也能分配给WSL2一个局域网地址
本方法需要通过Hyper-V虚拟网卡进行，因此首先需要安装并开启Windows的Hyper-V功能
修改桥接网络步骤如下(以下步骤均在管理员模式的Powershell中进行)：
从Powershell中开启wsl，生成网卡 wsl.exe 如果只是开机自启的wsl会出现找不到WSL网卡的错误 2. 获取网卡信息
Get-NetAdapter 运行之后可以查看当前Windows中的网卡设备，例如WLAN 3. 桥接网卡 选择WSL2需要桥接的网卡设备，以WLAN为例
Set-VMSwitch WSL -NetAdapterName WLAN 配置WSL2地址 这时，已经将WSL2的网卡桥接到物理网卡之上，需要手动配置WSL2的静态地址，假设路由器的网关为192.168.8.1，需要配置静态地址为192.168.8.123，则可以按照以下步骤进行配置(在WSL2中进行) sudo ip addr flush dev eth0 sudo ip addr add 192.168.8.123/24 dev eth0 sudo ip route add 0.0.0.0/0 via 192.168.8.1 dev eth0 更改过后还需手动更改DNS地址
# /etc/resolv.conf nameserver 192.168.8.1 保存并退出
以上就完成了WSL2的桥接网络配置，需要注意的是，每次都需要手动更新DNS文件，如果连接到别的路由器之下还需要手动更新静态地址和网关地址</description></item><item><title>Ubuntu20.04 Install Opencv3.1.0 With Python3</title><link>https://blog.thinkmoe.icu/posts/ubuntu20.04-install-opencv3.1.0-with-python3/</link><pubDate>Mon, 28 Mar 2022 16:40:37 +0800</pubDate><guid>https://blog.thinkmoe.icu/posts/ubuntu20.04-install-opencv3.1.0-with-python3/</guid><description>安装依赖 Ubuntu20.04需要安装以下依赖
sudo apt install -y --no-install-recommends \ build-essential \ git \ wget \ unzip \ yasm \ pkg-config \ libswscale-dev \ libtbb2 \ libtbb-dev \ libjpeg-dev \ libpng-dev \ libtiff-dev \ libopenjp2-7-dev \ libavformat-dev \ libpq-dev \ libgtk2.0-dev libgtk-3-dev \ libgphoto2-dev \ libtiff5-dev libjpeg8-dev libpng-dev cmake make \ libavformat-dev libavcodec-dev libswscale-dev libdc1394-22-dev libavresample-dev \ libxine2-dev libv4l-dev \ libatlas-base-dev \ libfaac-dev libmp3lame-dev libtheora-dev \ libvorbis-dev libxvidcore-dev \ libeigen3-dev \ libgstreamer1.0-0 gstreamer1.</description></item><item><title>Ubuntu Server 20.04 设置IP和网关地址</title><link>https://blog.thinkmoe.icu/posts/ubuntu-server-20.04-%E8%AE%BE%E7%BD%AEip%E5%9C%B0%E5%9D%80%E5%92%8C%E7%BD%91%E5%85%B3%E5%9C%B0%E5%9D%80/</link><pubDate>Thu, 19 Aug 2021 15:36:40 +0800</pubDate><guid>https://blog.thinkmoe.icu/posts/ubuntu-server-20.04-%E8%AE%BE%E7%BD%AEip%E5%9C%B0%E5%9D%80%E5%92%8C%E7%BD%91%E5%85%B3%E5%9C%B0%E5%9D%80/</guid><description>Ubuntu从20.04版本开始使用netplan对网络进行管理，百度上使用的/etc/network/interfaces文件已不再适用，需要修改netplan配置文件进行更新
修改配置文件 netplan的配置文件存放在/etc/netplan中，其中有诸如00-installer-config.yaml的配置文件，打开可以发现
# This is the network config written by &amp;#39;subiquity&amp;#39; network: ethernets: # 网卡名称，我这是虚拟机ens33 ens33: # 是否开启dhcp服务，设置为true后后续的ip和网关可以不用设置 dhcp4: no # IP地址，一般设置一个就行 # 后面的24是子网掩码数目，代表255.255.255.0(11111111.11111111.11111111.00000000) addresses: [192.168.1.106/24] optional: true # 网关地址 gateway4: 192.168.1.253 # dns地址 nameservers: addresses: [233.5.5.5, 192.168.1.253] version: 2 当然，这只是最为基础的网络配置，对于多张网卡还可以进行其他的配置，详情可以参考Netplan官方文档
在修改完文件之后，终端输入以下命令应用配置，Ping外网测试连通性
sudo netplay apply ping 8.8.8.8</description></item><item><title>利用fusuma为Linux添加触控板手势</title><link>https://blog.thinkmoe.icu/posts/%E5%88%A9%E7%94%A8fusuma%E4%B8%BAlinux%E6%B7%BB%E5%8A%A0%E8%A7%A6%E6%8E%A7%E6%9D%BF%E6%89%8B%E5%8A%BF/</link><pubDate>Sat, 19 Jun 2021 21:07:52 +0800</pubDate><guid>https://blog.thinkmoe.icu/posts/%E5%88%A9%E7%94%A8fusuma%E4%B8%BAlinux%E6%B7%BB%E5%8A%A0%E8%A7%A6%E6%8E%A7%E6%9D%BF%E6%89%8B%E5%8A%BF/</guid><description>之前一直在新笔记本上用虚拟机开Linux编写毕设，现在毕业答辩已经完成，所以就直接将Win10更换到Linux系统。但是众所周知，Linux并没有自带触控板手势驱动，但我早已习惯于win上的一些手势，所以我开始寻找一个合适的触控板手势驱动。
在最初，我发现了一个名为libinput-gesture的库，其Github上有3k赞，于是我立马就尝试了这个库。安装过程一切畅通，但最后运行的阶段却出了问题。在启动该库时提示我启动失败，但并没有给其他错误信息。我检查了xinput和libinput对触控板的驱动，并没有任何问题。谷歌了一下发现这玩意对arch用户非常良好，但对我这使用的ubuntu来说会出现这种情况。于是我把目光转向另一个库，fusuma。
fusuma这个包非常完美的解决了Ubuntu触控板手势的问题，并且安装过程极其简单，配置也十分简洁明了。
安装 配置用户权限 首先需要配置一下用户状态组，将用户添加到input组中
sudo gpasswd -a $USER input newgrp input // 立刻刷新 对于Debian系用户(Ubuntu,Debian,Mint,Pop!OS) 安装libinput sudo apt install libinput-tools 安装Ruby 由于fusuma需要在ruby上运行，因此需要安装ruby。
sudo apt install ruby 安装Fusuma sudo gem install fusuma 安装xdotool(可选，但是对后续非常有用建议安装) sudo apt install xdotool 对于Arch用户 sudo pacman -S libinput ruby xdotool sudo gem install fusuma 启动 fusuma 配置 Fusuma的配置非常简单，首先需要在用户目录下创建配置文件~/.config/fusuma/config.yml
mkdir -p $HOME/.config/fusuma touch $HOME/.config/fusuma/config.yml 这里简单贴出我使用的配置，可以在配置中发现，其实手势是通过xdotool工具间接调用系统的快捷键来实现手势控制的
swipe: 3: left: command: &amp;#34;xdotool key alt+Right&amp;#34; # History forward right: command: &amp;#34;xdotool key alt+Left&amp;#34; # History back #up: #command: &amp;#34;xdotool key super&amp;#34; # Activity #down: #command: &amp;#34;xdotool key super&amp;#34; # Activity 4: left: command: &amp;#34;xdotool key alt+u&amp;#34; # Switch to next workspace right: command: &amp;#34;xdotool key alt+d&amp;#34; # Switch to previous workspace up: command: &amp;#34;xdotool key alt+u&amp;#34; # Switch to next workspace down: command: &amp;#34;xdotool key alt+d&amp;#34; # Switch to previous workspace pinch: in: command: &amp;#34;xdotool keydown ctrl click 4 keyup ctrl&amp;#34; # Zoom in out: command: &amp;#34;xdotool keydown ctrl click 5 keyup ctrl&amp;#34; # Zoom out 在添加完配置文件后，重新启动fusuma即可使用手势动作了</description></item></channel></rss>