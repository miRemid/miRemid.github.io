<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Linux on 狸猫窝</title><link>https://blog.thinkmoe.icu/tags/linux/</link><description>Recent content in Linux on 狸猫窝</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Thu, 05 May 2022 13:34:24 +0800</lastBuildDate><atom:link href="https://blog.thinkmoe.icu/tags/linux/index.xml" rel="self" type="application/rss+xml"/><item><title>WSL2更改桥接网络</title><link>https://blog.thinkmoe.icu/posts/wsl2%E6%9B%B4%E6%94%B9%E6%A1%A5%E6%8E%A5%E7%BD%91%E7%BB%9C/</link><pubDate>Thu, 05 May 2022 13:34:24 +0800</pubDate><guid>https://blog.thinkmoe.icu/posts/wsl2%E6%9B%B4%E6%94%B9%E6%A1%A5%E6%8E%A5%E7%BD%91%E7%BB%9C/</guid><description>WSL2默认情况下网络是处于NAT模式之下，在正常情况下联网是没有问题的，但是遇到一些特殊情况下时NAT网络就非常的鸡肋。 例如，NAT的WSL2并不能直接使用宿主机的代理服务器，需要手动获取本机IP和宿主机在WSL2中的IP地址才能进行局域网连接。 在例如本人需要在WSL2中远程连接实验室车辆上的ROS2节点，由于NAT的存在导致小车上ROS2节点发布的Topic并不能在WSL2中接收到，因此我需要将WSL2默认的NAT网络 更改为桥接网络，这样在不影响宿主机上网的同时也能分配给WSL2一个局域网地址
本方法需要通过Hyper-V虚拟网卡进行，因此首先需要安装并开启Windows的Hyper-V功能
修改桥接网络步骤如下(以下步骤均在管理员模式的Powershell中进行)：
从Powershell中开启wsl，生成网卡 wsl.exe 如果只是开机自启的wsl会出现找不到WSL网卡的错误 2. 获取网卡信息
Get-NetAdapter 运行之后可以查看当前Windows中的网卡设备，例如WLAN 3. 桥接网卡 选择WSL2需要桥接的网卡设备，以WLAN为例
Set-VMSwitch WSL -NetAdapterName WLAN 配置WSL2地址 这时，已经将WSL2的网卡桥接到物理网卡之上，需要手动配置WSL2的静态地址，假设路由器的网关为192.168.8.1，需要配置静态地址为192.168.8.123，则可以按照以下步骤进行配置(在WSL2中进行) sudo ip addr flush dev eth0 sudo ip addr add 192.168.8.123/24 dev eth0 sudo ip route add 0.0.0.0/0 via 192.168.8.1 dev eth0 更改过后还需手动更改DNS地址
# /etc/resolv.conf nameserver 192.168.8.1 保存并退出
以上就完成了WSL2的桥接网络配置，需要注意的是，每次都需要手动更新DNS文件，如果连接到别的路由器之下还需要手动更新静态地址和网关地址</description></item><item><title>Ubuntu20.04 Install Opencv3.1.0 With Python3</title><link>https://blog.thinkmoe.icu/posts/ubuntu20.04-install-opencv3.1.0-with-python3/</link><pubDate>Mon, 28 Mar 2022 16:40:37 +0800</pubDate><guid>https://blog.thinkmoe.icu/posts/ubuntu20.04-install-opencv3.1.0-with-python3/</guid><description>安装依赖 Ubuntu20.04需要安装以下依赖
sudo apt install -y --no-install-recommends \ build-essential \ git \ wget \ unzip \ yasm \ pkg-config \ libswscale-dev \ libtbb2 \ libtbb-dev \ libjpeg-dev \ libpng-dev \ libtiff-dev \ libopenjp2-7-dev \ libavformat-dev \ libpq-dev \ libgtk2.0-dev libgtk-3-dev \ libgphoto2-dev \ libtiff5-dev libjpeg8-dev libpng-dev cmake make \ libavformat-dev libavcodec-dev libswscale-dev libdc1394-22-dev libavresample-dev \ libxine2-dev libv4l-dev \ libatlas-base-dev \ libfaac-dev libmp3lame-dev libtheora-dev \ libvorbis-dev libxvidcore-dev \ libeigen3-dev \ libgstreamer1.</description></item><item><title>Ubuntu Server 20.04 设置IP和网关地址</title><link>https://blog.thinkmoe.icu/posts/ubuntu-server-20.04-%E8%AE%BE%E7%BD%AEip%E5%9C%B0%E5%9D%80%E5%92%8C%E7%BD%91%E5%85%B3%E5%9C%B0%E5%9D%80/</link><pubDate>Thu, 19 Aug 2021 15:36:40 +0800</pubDate><guid>https://blog.thinkmoe.icu/posts/ubuntu-server-20.04-%E8%AE%BE%E7%BD%AEip%E5%9C%B0%E5%9D%80%E5%92%8C%E7%BD%91%E5%85%B3%E5%9C%B0%E5%9D%80/</guid><description>Ubuntu从20.04版本开始使用netplan对网络进行管理，百度上使用的/etc/network/interfaces文件已不再适用，需要修改netplan配置文件进行更新
修改配置文件 netplan的配置文件存放在/etc/netplan中，其中有诸如00-installer-config.yaml的配置文件，打开可以发现
# This is the network config written by &amp;#39;subiquity&amp;#39;network:ethernets:# 网卡名称，我这是虚拟机ens33ens33:# 是否开启dhcp服务，设置为true后后续的ip和网关可以不用设置dhcp4:no# IP地址，一般设置一个就行# 后面的24是子网掩码数目，代表255.255.255.0(11111111.11111111.11111111.00000000)addresses:[192.168.1.106/24]optional:true# 网关地址gateway4:192.168.1.253# dns地址nameservers:addresses:[233.5.5.5,192.168.1.253]version:2当然，这只是最为基础的网络配置，对于多张网卡还可以进行其他的配置，详情可以参考Netplan官方文档
在修改完文件之后，终端输入以下命令应用配置，Ping外网测试连通性
sudo netplay apply ping 8.8.8.8</description></item><item><title>利用fusuma为Linux添加触控板手势</title><link>https://blog.thinkmoe.icu/posts/%E5%88%A9%E7%94%A8fusuma%E4%B8%BAlinux%E6%B7%BB%E5%8A%A0%E8%A7%A6%E6%8E%A7%E6%9D%BF%E6%89%8B%E5%8A%BF/</link><pubDate>Sat, 19 Jun 2021 21:07:52 +0800</pubDate><guid>https://blog.thinkmoe.icu/posts/%E5%88%A9%E7%94%A8fusuma%E4%B8%BAlinux%E6%B7%BB%E5%8A%A0%E8%A7%A6%E6%8E%A7%E6%9D%BF%E6%89%8B%E5%8A%BF/</guid><description>之前一直在新笔记本上用虚拟机开Linux编写毕设，现在毕业答辩已经完成，所以就直接将Win10更换到Linux系统。但是众所周知，Linux并没有自带触控板手势驱动，但我早已习惯于win上的一些手势，所以我开始寻找一个合适的触控板手势驱动。
在最初，我发现了一个名为libinput-gesture的库，其Github上有3k赞，于是我立马就尝试了这个库。安装过程一切畅通，但最后运行的阶段却出了问题。在启动该库时提示我启动失败，但并没有给其他错误信息。我检查了xinput和libinput对触控板的驱动，并没有任何问题。谷歌了一下发现这玩意对arch用户非常良好，但对我这使用的ubuntu来说会出现这种情况。于是我把目光转向另一个库，fusuma。
fusuma这个包非常完美的解决了Ubuntu触控板手势的问题，并且安装过程极其简单，配置也十分简洁明了。
安装 配置用户权限 首先需要配置一下用户状态组，将用户添加到input组中
sudo gpasswd -a $USER input newgrp input // 立刻刷新 对于Debian系用户(Ubuntu,Debian,Mint,Pop!OS) 安装libinput sudo apt install libinput-tools 安装Ruby 由于fusuma需要在ruby上运行，因此需要安装ruby。
sudo apt install ruby 安装Fusuma sudo gem install fusuma 安装xdotool(可选，但是对后续非常有用建议安装) sudo apt install xdotool 对于Arch用户 sudo pacman -S libinput ruby xdotool sudo gem install fusuma 启动 fusuma 配置 Fusuma的配置非常简单，首先需要在用户目录下创建配置文件~/.config/fusuma/config.yml
mkdir -p $HOME/.config/fusuma touch $HOME/.config/fusuma/config.yml 这里简单贴出我使用的配置，可以在配置中发现，其实手势是通过xdotool工具间接调用系统的快捷键来实现手势控制的
swipe:3:left:command:&amp;#34;xdotool key alt+Right&amp;#34;# History forwardright:command:&amp;#34;xdotool key alt+Left&amp;#34;# History back#up:#command: &amp;#34;xdotool key super&amp;#34; # Activity#down:#command: &amp;#34;xdotool key super&amp;#34; # Activity4:left:command:&amp;#34;xdotool key alt+u&amp;#34;# Switch to next workspaceright:command:&amp;#34;xdotool key alt+d&amp;#34;# Switch to previous workspaceup:command:&amp;#34;xdotool key alt+u&amp;#34;# Switch to next workspacedown:command:&amp;#34;xdotool key alt+d&amp;#34;# Switch to previous workspacepinch:in:command:&amp;#34;xdotool keydown ctrl click 4 keyup ctrl&amp;#34;# Zoom inout:command:&amp;#34;xdotool keydown ctrl click 5 keyup ctrl&amp;#34;# Zoom out在添加完配置文件后，重新启动fusuma即可使用手势动作了</description></item></channel></rss>